<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CustomJooqAutoGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">SwaggerCodeGen</a> &gt; <a href="index.source.html" class="el_package">org.gemini.codegen.JOOQ.PojosGen</a> &gt; <span class="el_source">CustomJooqAutoGenerator.java</span></div><h1>CustomJooqAutoGenerator.java</h1><pre class="source lang-java linenums">package org.gemini.codegen.JOOQ.PojosGen;

import org.jooq.Configuration;
import org.jooq.Constants;
import org.jooq.Record;
import org.jooq.codegen.*;
import org.jooq.impl.DAOImpl;
import org.jooq.meta.*;
import org.jooq.tools.JooqLogger;
import org.jooq.tools.StringUtils;


import java.beans.ConstructorProperties;
import java.util.ArrayList;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;


<span class="fc" id="L21">public class CustomJooqAutoGenerator extends JavaGenerator {</span>

<span class="fc" id="L23">    private static final JooqLogger LOG = JooqLogger.getLogger(CustomJooqAutoGenerator.class);</span>


    @Override
    protected void generatePojo(TableDefinition table) {
<span class="fc" id="L28">        JavaWriter out = newJavaWriter(getFile(table, GeneratorStrategy.Mode.POJO));</span>
<span class="fc" id="L29">        LOG.info(&quot;Generating POJO &quot;, out.file().getName());</span>
<span class="fc" id="L30">        generatePojo(table, out);</span>
<span class="fc" id="L31">        closeJavaWriter(out);</span>
<span class="fc" id="L32">        super.generatePojo(table);</span>
<span class="fc" id="L33">    }</span>

    protected void generatePojo(TableDefinition table, JavaWriter out) {
<span class="fc" id="L36">        generatePojo0(table, out);</span>
<span class="fc" id="L37">    }</span>

    private final void generatePojo0(Definition tableUdtOrEmbeddable, JavaWriter out) {
<span class="fc" id="L40">        final String className = getStrategy().getJavaClassName(tableUdtOrEmbeddable, GeneratorStrategy.Mode.POJO);</span>
<span class="pc bpc" id="L41" title="1 of 2 branches missed.">        final String interfaceName = generateInterfaces()</span>
<span class="nc" id="L42">                ? out.ref(getStrategy().getFullJavaClassName(tableUdtOrEmbeddable, GeneratorStrategy.Mode.INTERFACE))</span>
<span class="fc" id="L43">                : &quot;&quot;;</span>
<span class="fc" id="L44">        final String superName = out.ref(getStrategy().getJavaClassExtends(tableUdtOrEmbeddable, GeneratorStrategy.Mode.POJO));</span>
<span class="fc" id="L45">        final List&lt;String&gt; interfaces = out.ref(getStrategy().getJavaClassImplements(tableUdtOrEmbeddable, GeneratorStrategy.Mode.POJO));</span>

<span class="pc bpc" id="L47" title="1 of 2 branches missed.">        if (generateInterfaces())</span>
<span class="nc" id="L48">            interfaces.add(interfaceName);</span>

<span class="fc" id="L50">        final List&lt;String&gt; superTypes = list(superName, interfaces);</span>
<span class="fc" id="L51">        printPackage(out, tableUdtOrEmbeddable, GeneratorStrategy.Mode.POJO);</span>

<span class="pc bpc" id="L53" title="1 of 2 branches missed.">        if (tableUdtOrEmbeddable instanceof TableDefinition)</span>
<span class="fc" id="L54">            generatePojoClassJavadoc((TableDefinition) tableUdtOrEmbeddable, out);</span>
<span class="nc bnc" id="L55" title="All 2 branches missed.">        else if (tableUdtOrEmbeddable instanceof EmbeddableDefinition)</span>
<span class="nc" id="L56">            generateEmbeddableClassJavadoc((EmbeddableDefinition) tableUdtOrEmbeddable, out);</span>
        else
<span class="nc" id="L58">            generateUDTPojoClassJavadoc((UDTDefinition) tableUdtOrEmbeddable, out);</span>

<span class="fc" id="L60">        printClassAnnotations(out, tableUdtOrEmbeddable, GeneratorStrategy.Mode.POJO);</span>

<span class="pc bpc" id="L62" title="1 of 2 branches missed.">        if (tableUdtOrEmbeddable instanceof TableDefinition)</span>
<span class="fc" id="L63">            printTableJPAAnnotation(out, (TableDefinition) tableUdtOrEmbeddable);</span>

<span class="fc" id="L65">        int maxLength = 0;</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">        for (TypedElementDefinition&lt;?&gt; column : getTypedElements(tableUdtOrEmbeddable))</span>
<span class="fc" id="L67">            maxLength = Math.max(maxLength, out.ref(getJavaType(column.getType(resolver(out, GeneratorStrategy.Mode.POJO)), out, GeneratorStrategy.Mode.POJO)).length());</span>


<span class="fc" id="L70">        out.println(&quot;public class %s[[before= extends ][%s]][[before= implements ][%s]] {&quot;, className, list(superName), interfaces);</span>

<span class="pc bpc" id="L72" title="3 of 4 branches missed.">        if (generateSerializablePojos() || generateSerializableInterfaces())</span>
<span class="fc" id="L73">            out.printSerial();</span>

<span class="fc" id="L75">        out.println();</span>

<span class="fc bfc" id="L77" title="All 2 branches covered.">        for (TypedElementDefinition&lt;?&gt; column : getTypedElements(tableUdtOrEmbeddable)) {</span>
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">            if (column instanceof ColumnDefinition)</span>
<span class="fc" id="L79">                printColumnJPAAnnotation(out, (ColumnDefinition) column);</span>

<span class="fc" id="L81">            out.println(&quot;private %s%s %s;&quot;,</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">                    generateImmutablePojos() ? &quot;final &quot; : &quot;&quot;,</span>
<span class="fc" id="L83">                    StringUtils.rightPad(out.ref(getJavaType(column.getType(resolver(out, GeneratorStrategy.Mode.POJO)), out, GeneratorStrategy.Mode.POJO)), maxLength),</span>
<span class="fc" id="L84">                    getStrategy().getJavaMemberName(column, GeneratorStrategy.Mode.POJO));</span>

<span class="fc" id="L86">        }</span>

        // Constructors
        // ---------------------------------------------------------------------

        // Default constructor
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">        if (!generateImmutablePojos())</span>
<span class="fc" id="L93">            generatePojoDefaultConstructor(tableUdtOrEmbeddable, out);</span>


        // [#1363] [#7055] copy constructor
<span class="fc" id="L97">        generatePojoCopyConstructor(tableUdtOrEmbeddable, out);</span>

        // Multi-constructor
<span class="fc" id="L100">        generatePojoMultiConstructor(tableUdtOrEmbeddable, out);</span>

<span class="fc" id="L102">        List&lt;? extends TypedElementDefinition&lt;?&gt;&gt; elements = getTypedElements(tableUdtOrEmbeddable);</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">        for (int i = 0; i &lt; elements.size(); i++) {</span>
<span class="fc" id="L104">            TypedElementDefinition&lt;?&gt; column = elements.get(i);</span>

<span class="pc bpc" id="L106" title="1 of 2 branches missed.">            if (tableUdtOrEmbeddable instanceof TableDefinition)</span>
<span class="fc" id="L107">                generatePojoGetter(column, i, out);</span>
            else
<span class="nc" id="L109">                generateUDTPojoGetter(column, i, out);</span>

            // Setter
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">            if (!generateImmutablePojos())</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">                if (tableUdtOrEmbeddable instanceof TableDefinition)</span>
<span class="fc" id="L114">                    generatePojoSetter(column, i, out);</span>
                else
<span class="nc" id="L116">                    generateUDTPojoSetter(column, i, out);</span>
        }


<span class="pc bpc" id="L120" title="1 of 2 branches missed.">        if (tableUdtOrEmbeddable instanceof TableDefinition) {</span>
<span class="fc" id="L121">            List&lt;EmbeddableDefinition&gt; embeddables = ((TableDefinition) tableUdtOrEmbeddable).getReferencedEmbeddables();</span>

<span class="pc bpc" id="L123" title="1 of 2 branches missed.">            for (int i = 0; i &lt; embeddables.size(); i++) {</span>
<span class="nc" id="L124">                EmbeddableDefinition embeddable = embeddables.get(i);</span>

<span class="nc" id="L126">                generateEmbeddablePojoSetter(embeddable, i, out);</span>
<span class="nc" id="L127">                generateEmbeddablePojoGetter(embeddable, i, out);</span>
            }
        }

<span class="pc bpc" id="L131" title="1 of 2 branches missed.">        if (generatePojosEqualsAndHashCode())</span>
<span class="nc" id="L132">            generatePojoEqualsAndHashCode(tableUdtOrEmbeddable, out);</span>

<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (generatePojosToString())</span>
<span class="fc" id="L135">            generatePojoToString(tableUdtOrEmbeddable, out);</span>

<span class="pc bpc" id="L137" title="3 of 4 branches missed.">        if (generateInterfaces() &amp;&amp; !generateImmutablePojos())</span>
<span class="nc" id="L138">            printFromAndInto(out, tableUdtOrEmbeddable, GeneratorStrategy.Mode.POJO);</span>

<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        if (tableUdtOrEmbeddable instanceof TableDefinition)</span>
<span class="fc" id="L141">            generatePojoClassFooter((TableDefinition) tableUdtOrEmbeddable, out);</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">        else if (tableUdtOrEmbeddable instanceof EmbeddableDefinition)</span>
<span class="nc" id="L143">            generateEmbeddableClassFooter((EmbeddableDefinition) tableUdtOrEmbeddable, out);</span>
        else
<span class="nc" id="L145">            generateUDTPojoClassFooter((UDTDefinition) tableUdtOrEmbeddable, out);</span>

<span class="fc" id="L147">        out.println(&quot;}&quot;);</span>
<span class="fc" id="L148">        closeJavaWriter(out);</span>
<span class="fc" id="L149">    }</span>
    protected void printColumnJPAAnnotation(JavaWriter out, ColumnDefinition column) {
<span class="fc" id="L151">        int indent = out.indent();</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        if (this.generateJPAAnnotations()) {</span>
<span class="fc" id="L153">            String prefix =&quot;&quot;;</span>
<span class="fc" id="L154">            UniqueKeyDefinition pk = column.getPrimaryKey();</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">            if (pk != null) {</span>
<span class="fc" id="L156">                out.println(&quot;@%s%s&quot;, new Object[]{prefix, out.ref(&quot;javax.persistence.Id&quot;)});</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">                for (ColumnDefinition s:pk.getKeyColumns()) {</span>
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">                    if(s.isIdentity())</span>
                    {
<span class="fc" id="L160">                        out.println(&quot;@%s%s(strategy = %s.IDENTITY)&quot;, new Object[]{prefix, out.ref(&quot;javax.persistence.GeneratedValue&quot;), out.ref(&quot;javax.persistence.GenerationType&quot;)});</span>
                    }
<span class="fc" id="L162">                }</span>
            }

<span class="fc" id="L165">            String nullable = &quot;&quot;;</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">            if (!column.getType(this.resolver(out)).isNullable()) {</span>
<span class="fc" id="L167">                nullable = &quot;, nullable = false&quot;;</span>
            }

<span class="fc" id="L170">            String length = &quot;&quot;;</span>
<span class="fc" id="L171">            String precision = &quot;&quot;;</span>
<span class="fc" id="L172">            String scale = &quot;&quot;;</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">            if (column.getType(this.resolver(out)).getLength() &gt; 0) {</span>
<span class="fc" id="L174">                length = &quot;, length = &quot; + column.getType(this.resolver(out)).getLength();</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">            } else if (column.getType(this.resolver(out)).getPrecision() &gt; 0) {</span>
<span class="fc" id="L176">                precision = &quot;, precision = &quot; + column.getType(this.resolver(out)).getPrecision();</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">                if (column.getType(this.resolver(out)).getScale() &gt; 0) {</span>
<span class="nc" id="L178">                    scale = &quot;, scale = &quot; + column.getType(this.resolver(out)).getScale();</span>
                }
            }

<span class="fc" id="L182">            out.print(&quot;@%s%s(name = \&quot;&quot;, new Object[]{prefix, out.ref(&quot;javax.persistence.Column&quot;)});</span>
<span class="fc" id="L183">            out.print(this.escapeString(column.getName()));</span>
<span class="fc" id="L184">            out.print(&quot;\&quot;&quot;);</span>
<span class="fc" id="L185">            out.print(nullable);</span>
<span class="fc" id="L186">            out.print(length);</span>
<span class="fc" id="L187">            out.print(precision);</span>
<span class="fc" id="L188">            out.print(scale);</span>
<span class="fc" id="L189">            out.println(&quot;)&quot;);</span>
        }

<span class="fc" id="L192">        out.indent(indent);</span>
<span class="fc" id="L193">    }</span>
    protected void generatePojoMultiConstructor(Definition tableOrUDT, JavaWriter out) {
<span class="fc" id="L195">        final String className = getStrategy().getJavaClassName(tableOrUDT, GeneratorStrategy.Mode.POJO);</span>
<span class="fc" id="L196">        final List&lt;String&gt; properties = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L198">        int maxLength = 0;</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">        for (TypedElementDefinition&lt;?&gt; column : getTypedElements(tableOrUDT)) {</span>
<span class="fc" id="L200">            maxLength = Math.max(maxLength, out.ref(getJavaType(column.getType(resolver(out, GeneratorStrategy.Mode.POJO)), out, GeneratorStrategy.Mode.POJO)).length());</span>
<span class="fc" id="L201">            properties.add(&quot;\&quot;&quot; + escapeString(getStrategy().getJavaMemberName(column, GeneratorStrategy.Mode.POJO)) + &quot;\&quot;&quot;);</span>
<span class="fc" id="L202">        }</span>


        // [#3010] Invalid UDTs may have no attributes. Avoid generating this constructor in that case
        // [#3176] Avoid generating constructors for tables with more than 255 columns (Java's method argument limit)
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (getTypedElements(tableOrUDT).size() &gt; 0 &amp;&amp;</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">                getTypedElements(tableOrUDT).size() &lt; 256) {</span>
<span class="fc" id="L209">            out.println();</span>

<span class="pc bpc" id="L211" title="1 of 2 branches missed.">            if (generateConstructorPropertiesAnnotationOnPojos())</span>
<span class="fc" id="L212">                out.println(&quot;@%s({ [[%s]] })&quot;, ConstructorProperties.class, properties);</span>

<span class="fc" id="L214">            out.print(&quot;public %s(&quot;, className);</span>

<span class="fc" id="L216">            String separator1 = &quot;&quot;;</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">            for (TypedElementDefinition&lt;?&gt; column : getTypedElements(tableOrUDT)) {</span>
<span class="fc" id="L218">                final String nullableAnnotation = nullableOrNonnullAnnotation(out, column);</span>

<span class="fc" id="L220">                out.println(separator1);</span>
<span class="fc" id="L221">                out.print(&quot;[[before=@][after= ][%s]]%s %s&quot;,</span>
<span class="fc" id="L222">                        list(nullableAnnotation),</span>
<span class="fc" id="L223">                        StringUtils.rightPad(out.ref(getJavaType(column.getType(resolver(out, GeneratorStrategy.Mode.POJO)), out, GeneratorStrategy.Mode.POJO)), maxLength),</span>
<span class="fc" id="L224">                        getStrategy().getJavaMemberName(column, GeneratorStrategy.Mode.POJO));</span>
<span class="fc" id="L225">                separator1 = &quot;,&quot;;</span>
<span class="fc" id="L226">            }</span>

<span class="fc" id="L228">            out.println();</span>
<span class="fc" id="L229">            out.println(&quot;) {&quot;);</span>

<span class="fc bfc" id="L231" title="All 2 branches covered.">            for (TypedElementDefinition&lt;?&gt; column : getTypedElements(tableOrUDT)) {</span>
<span class="fc" id="L232">                final String columnMember = getStrategy().getJavaMemberName(column, GeneratorStrategy.Mode.POJO);</span>

<span class="fc" id="L234">                out.println(&quot;this.%s = %s;&quot;, columnMember, columnMember);</span>
<span class="fc" id="L235">            }</span>

<span class="fc" id="L237">            out.println(&quot;}&quot;);</span>
        }
<span class="fc" id="L239">    }</span>

    /**
     * Subclasses may override this method to provide their own pojo copy constructors.
     */
    protected void generatePojoCopyConstructor(Definition tableOrUDT, JavaWriter out) {
<span class="fc" id="L245">        final String className = getStrategy().getJavaClassName(tableOrUDT, GeneratorStrategy.Mode.POJO);</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">        final String interfaceName = generateInterfaces()</span>
<span class="nc" id="L247">                ? out.ref(getStrategy().getFullJavaClassName(tableOrUDT, GeneratorStrategy.Mode.INTERFACE))</span>
<span class="fc" id="L248">                : &quot;&quot;;</span>

<span class="fc" id="L250">        out.println();</span>

<span class="pc bpc" id="L252" title="1 of 2 branches missed.">        out.println(&quot;public %s(%s value) {&quot;, className, generateInterfaces() ? interfaceName : className);</span>

<span class="fc bfc" id="L254" title="All 2 branches covered.">        for (TypedElementDefinition&lt;?&gt; column : getTypedElements(tableOrUDT)) {</span>
<span class="fc" id="L255">            out.println(&quot;this.%s = value.%s%s;&quot;,</span>
<span class="fc" id="L256">                    getStrategy().getJavaMemberName(column, GeneratorStrategy.Mode.POJO),</span>
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">                    generateInterfaces()</span>
<span class="nc" id="L258">                            ? getStrategy().getJavaGetterName(column, GeneratorStrategy.Mode.INTERFACE)</span>
<span class="fc" id="L259">                            : getStrategy().getJavaMemberName(column, GeneratorStrategy.Mode.POJO),</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">                    generateInterfaces()</span>
<span class="nc" id="L261">                            ? &quot;()&quot;</span>
<span class="fc" id="L262">                            : &quot;&quot;);</span>


<span class="fc" id="L265">        }</span>
<span class="fc" id="L266">        out.println(&quot;}&quot;);</span>
<span class="fc" id="L267">    }</span>

    /**
     * Subclasses may override this method to provide their own pojo default constructors.
     */
    protected void generatePojoDefaultConstructor(Definition tableOrUDT, JavaWriter out) {
<span class="fc" id="L273">        final String className = getStrategy().getJavaClassName(tableOrUDT, GeneratorStrategy.Mode.POJO);</span>

<span class="fc" id="L275">        out.println();</span>
<span class="fc" id="L276">        int size = getTypedElements(tableOrUDT).size();</span>
        // [#6248] [#10288] The no-args constructor isn't needed because we have named, defaulted parameters
<span class="fc" id="L278">        out.println(&quot;public %s() {}&quot;, className);</span>

<span class="fc" id="L280">    }</span>


    @Override
    protected void generatePojoGetter(TypedElementDefinition&lt;?&gt; column, int index, JavaWriter out) {
<span class="fc" id="L285">        generatePojoGetter0(column, index, out);</span>
<span class="fc" id="L286">    }</span>

    /**
     * Subclasses may override this method to provide their own pojo getters.
     */

    private final void generatePojoGetter0(TypedElementDefinition&lt;?&gt; column, @SuppressWarnings(&quot;unused&quot;) int index, JavaWriter out) {
<span class="fc" id="L293">        final String columnTypeFull = getJavaType(column.getType(resolver(out, GeneratorStrategy.Mode.POJO)), out, GeneratorStrategy.Mode.POJO);</span>
<span class="fc" id="L294">        final String columnType = out.ref(columnTypeFull);</span>
<span class="fc" id="L295">        final String columnGetter = getStrategy().getJavaGetterName(column, GeneratorStrategy.Mode.POJO);</span>
<span class="fc" id="L296">        final String columnMember = getStrategy().getJavaMemberName(column, GeneratorStrategy.Mode.POJO);</span>
<span class="fc" id="L297">        final String name = column.getQualifiedOutputName();</span>

        // Getter
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">        if (!printDeprecationIfUnknownType(out, columnTypeFull))</span>
<span class="fc" id="L301">            out.javadoc(&quot;Getter for &lt;code&gt;%s&lt;/code&gt;.[[before= ][%s]]&quot;, name, list(escapeEntities(comment(column))));</span>


<span class="fc" id="L304">        printValidationAnnotation(out, column);</span>
<span class="fc" id="L305">        printNullableOrNonnullAnnotation(out, column);</span>


<span class="fc" id="L308">        out.overrideIf(generateInterfaces());</span>
<span class="fc" id="L309">        out.println(&quot;public %s %s() {&quot;, columnType, columnGetter);</span>
<span class="fc" id="L310">        out.println(&quot;return this.%s;&quot;, columnMember);</span>
<span class="fc" id="L311">        out.println(&quot;}&quot;);</span>

<span class="fc" id="L313">    }</span>

    private void printValidationAnnotation(JavaWriter out, TypedElementDefinition&lt;?&gt; column) {
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        if (generateValidationAnnotations()) {</span>
<span class="fc" id="L317">            String prefix = &quot;&quot;;</span>
<span class="fc" id="L318">            DataTypeDefinition type = column.getType(resolver(out));</span>

            // [#5128] defaulted columns are nullable in Java
<span class="fc bfc" id="L321" title="All 2 branches covered.">            if (!column.getType(resolver(out)).isNullable() &amp;&amp;</span>
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">                    !column.getType(resolver(out)).isDefaulted() &amp;&amp;</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">                    !column.getType(resolver(out)).isIdentity())</span>
<span class="fc" id="L324">                out.println(&quot;@%s%s&quot;, prefix, out.ref(&quot;javax.validation.constraints.NotNull&quot;));</span>

<span class="fc" id="L326">            String javaType = getJavaType(type, out);</span>
<span class="pc bpc" id="L327" title="1 of 4 branches missed.">            if (&quot;java.lang.String&quot;.equals(javaType) || &quot;byte[]&quot;.equals(javaType)) {</span>
<span class="fc" id="L328">                int length = type.getLength();</span>

<span class="pc bpc" id="L330" title="1 of 2 branches missed.">                if (length &gt; 0)</span>
<span class="fc" id="L331">                    out.println(&quot;@%s%s(max = %s)&quot;, prefix, out.ref(&quot;javax.validation.constraints.Size&quot;), length);</span>
            }
        }
<span class="fc" id="L334">    }</span>

    private void printNullableOrNonnullAnnotation(JavaWriter out, Definition column) {
<span class="pc bpc" id="L337" title="1 of 4 branches missed.">        if (column instanceof TypedElementDefinition &amp;&amp; ((TypedElementDefinition&lt;?&gt;) column).getType().isNullable())</span>
<span class="fc" id="L338">            printNullableAnnotation(out);</span>
        else
<span class="fc" id="L340">            printNonnullAnnotation(out);</span>
<span class="fc" id="L341">    }</span>

    protected void printNullableAnnotation(JavaWriter out) {
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">        if (generateNullableAnnotation())</span>
<span class="nc" id="L345">            out.println(&quot;@%s&quot;, out.ref(generatedNullableAnnotationType()));</span>
<span class="fc" id="L346">    }</span>

    protected void printNonnullAnnotation(JavaWriter out) {
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">        if (generateNonnullAnnotation())</span>
<span class="nc" id="L350">            out.println(&quot;@%s&quot;, out.ref(generatedNonnullAnnotationType()));</span>
<span class="fc" id="L351">    }</span>

    private String comment(Definition definition) {
<span class="pc bpc" id="L354" title="3 of 4 branches missed.">        return definition instanceof CatalogDefinition &amp;&amp; generateCommentsOnCatalogs()</span>
<span class="pc bpc" id="L355" title="3 of 4 branches missed.">                || definition instanceof SchemaDefinition &amp;&amp; generateCommentsOnSchemas()</span>
<span class="pc bpc" id="L356" title="3 of 4 branches missed.">                || definition instanceof TableDefinition &amp;&amp; generateCommentsOnTables()</span>
<span class="pc bpc" id="L357" title="3 of 4 branches missed.">                || definition instanceof ColumnDefinition &amp;&amp; generateCommentsOnColumns()</span>
<span class="nc bnc" id="L358" title="All 4 branches missed.">                || definition instanceof EmbeddableDefinition &amp;&amp; generateCommentsOnEmbeddables()</span>
<span class="nc bnc" id="L359" title="All 4 branches missed.">                || definition instanceof UDTDefinition &amp;&amp; generateCommentsOnUDTs()</span>
<span class="nc bnc" id="L360" title="All 4 branches missed.">                || definition instanceof AttributeDefinition &amp;&amp; generateCommentsOnAttributes()</span>
<span class="nc bnc" id="L361" title="All 4 branches missed.">                || definition instanceof PackageDefinition &amp;&amp; generateCommentsOnPackages()</span>
<span class="nc bnc" id="L362" title="All 4 branches missed.">                || definition instanceof RoutineDefinition &amp;&amp; generateCommentsOnRoutines()</span>
<span class="nc bnc" id="L363" title="All 4 branches missed.">                || definition instanceof ParameterDefinition &amp;&amp; generateCommentsOnParameters()</span>
<span class="pc bpc" id="L364" title="3 of 4 branches missed.">                || definition instanceof SequenceDefinition &amp;&amp; generateCommentsOnSequences()</span>
<span class="fc" id="L365">                ? StringUtils.defaultIfBlank(definition.getComment(), &quot;&quot;)</span>
<span class="nc" id="L366">                : &quot;&quot;;</span>
    }


    private boolean printDeprecationIfUnknownType(JavaWriter out, String type) {
<span class="pc bpc" id="L371" title="4 of 6 branches missed.">        if (generateDeprecationOnUnknownTypes() &amp;&amp; (Object.class.getName().equals(type) &amp;&amp; &quot;Any&quot;.equals(type))) {</span>

<span class="nc" id="L373">            out.javadoc(&quot;@deprecated Unknown data type. &quot;</span>
                    + &quot;Please define an explicit {@link org.jooq.Binding} to specify how this &quot;
                    + &quot;type should be handled. Deprecation can be turned off using {@literal &lt;deprecationOnUnknownTypes/&gt;} &quot;
                    + &quot;in your code generator configuration.&quot;);

<span class="nc" id="L378">            out.println(&quot;@%s&quot;, out.ref(Deprecated.class));</span>


<span class="nc" id="L381">            return true;</span>
        } else {
<span class="fc" id="L383">            return false;</span>
        }
    }


    private List&lt;? extends TypedElementDefinition&lt;? extends Definition&gt;&gt; getTypedElements(Definition definition) {
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        if (definition instanceof TableDefinition)</span>
<span class="fc" id="L390">            return ((TableDefinition) definition).getColumns();</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">        else if (definition instanceof EmbeddableDefinition)</span>
<span class="nc" id="L392">            return ((EmbeddableDefinition) definition).getColumns();</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">        else if (definition instanceof UDTDefinition)</span>
<span class="nc" id="L394">            return ((UDTDefinition) definition).getAttributes();</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">        else if (definition instanceof RoutineDefinition)</span>
<span class="nc" id="L396">            return ((RoutineDefinition) definition).getAllParameters();</span>
        else
<span class="nc" id="L398">            throw new IllegalArgumentException(&quot;Unsupported type : &quot; + definition);</span>
    }

    private void printFromAndInto(JavaWriter out, Definition tableOrUDT, GeneratorStrategy.Mode mode) {
<span class="nc" id="L402">        String qualified = out.ref(getStrategy().getFullJavaClassName(tableOrUDT, GeneratorStrategy.Mode.INTERFACE));</span>

<span class="nc" id="L404">        out.header(&quot;FROM and INTO&quot;);</span>
<span class="nc bnc" id="L405" title="All 4 branches missed.">        boolean override = generateInterfaces() &amp;&amp; !generateImmutableInterfaces();</span>


<span class="nc" id="L408">        out.overrideInheritIf(override);</span>
<span class="nc" id="L409">        out.println(&quot;public void from(%s from) {&quot;, qualified);</span>


<span class="nc bnc" id="L412" title="All 2 branches missed.">        for (TypedElementDefinition&lt;?&gt; column : getTypedElements(tableOrUDT)) {</span>
<span class="nc" id="L413">            final String setter = getStrategy().getJavaSetterName(column, GeneratorStrategy.Mode.INTERFACE);</span>
<span class="nc" id="L414">            final String getter = getStrategy().getJavaGetterName(column, GeneratorStrategy.Mode.INTERFACE);</span>

            // TODO: Use appropriate Mode here
<span class="nc" id="L417">            final String member = getStrategy().getJavaMemberName(column, GeneratorStrategy.Mode.POJO);</span>

<span class="nc" id="L419">            out.println(&quot;%s(from.%s());&quot;, setter, getter);</span>
<span class="nc" id="L420">        }</span>

<span class="nc" id="L422">        out.println(&quot;}&quot;);</span>

<span class="nc bnc" id="L424" title="All 2 branches missed.">        if (override) {</span>
            // [#10191] Java and Kotlin can produce overloads for this method despite
            // generic type erasure, but Scala cannot, see
            // https://twitter.com/lukaseder/status/1262652304773259264

<span class="nc" id="L429">            out.overrideInherit();</span>
<span class="nc" id="L430">            out.println(&quot;public &lt;E extends %s&gt; E into(E into) {&quot;, qualified);</span>
<span class="nc" id="L431">            out.println(&quot;into.from(this);&quot;);</span>
<span class="nc" id="L432">            out.println(&quot;return into;&quot;);</span>
<span class="nc" id="L433">            out.println(&quot;}&quot;);</span>

        }
<span class="nc" id="L436">    }</span>

    private static final &lt;T&gt; List&lt;T&gt; list(T first, List&lt;T&gt; remaining) {
<span class="fc" id="L439">        List&lt;T&gt; result = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L441">        result.addAll(list(first));</span>
<span class="fc" id="L442">        result.addAll(remaining);</span>

<span class="fc" id="L444">        return result;</span>
    }

    private static final &lt;T&gt; List&lt;T&gt; list(T... objects) {
<span class="fc" id="L448">        List&lt;T&gt; result = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L450" title="1 of 2 branches missed.">        if (objects != null)</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">            for (T object : objects)</span>
<span class="pc bpc" id="L452" title="1 of 4 branches missed.">                if (object != null &amp;&amp; !&quot;&quot;.equals(object))</span>
<span class="nc" id="L453">                    result.add(object);</span>

<span class="fc" id="L455">        return result;</span>
    }

    private String nullableOrNonnullAnnotation(JavaWriter out, Definition column) {
<span class="pc bpc" id="L459" title="1 of 4 branches missed.">        return (column instanceof TypedElementDefinition &amp;&amp; ((TypedElementDefinition&lt;?&gt;) column).getType().isNullable())</span>
<span class="fc" id="L460">                ? nullableAnnotation(out)</span>
<span class="fc" id="L461">                : nonnullAnnotation(out);</span>
    }

    private String nullableAnnotation(JavaWriter out) {
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">        return generateNullableAnnotation() ? out.ref(generatedNullableAnnotationType()) : null;</span>
    }

    private String nonnullAnnotation(JavaWriter out) {
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">        return generateNonnullAnnotation() ? out.ref(generatedNonnullAnnotationType()) : null;</span>
    }

    private String escapeString(String string) {

<span class="pc bpc" id="L474" title="1 of 2 branches missed.">        if (string == null)</span>
<span class="nc" id="L475">            return null;</span>

        // [#3450] Escape also the escape sequence, among other things that break Java strings.
<span class="fc" id="L478">        String result = string.replace(&quot;\\&quot;, &quot;\\\\&quot;)</span>
<span class="fc" id="L479">                .replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)</span>
<span class="fc" id="L480">                .replace(&quot;\n&quot;, &quot;\\n&quot;)</span>
<span class="fc" id="L481">                .replace(&quot;\r&quot;, &quot;\\r&quot;);</span>

        // [#10007] [#10318] Very long strings cannot be handled by the javac compiler.
<span class="fc" id="L484">        int max = 16384;</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">        if (result.length() &lt;= max)</span>
<span class="fc" id="L486">            return result;</span>

<span class="nc" id="L488">        StringBuilder sb = new StringBuilder(&quot;\&quot; + \&quot;&quot;);</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">        for (int i = 0; i &lt; result.length(); i += max) {</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">            if (i &gt; 0)</span>
<span class="nc" id="L491">                sb.append(&quot;\&quot;.toString() + \&quot;&quot;);</span>

<span class="nc" id="L493">            sb.append(result.substring(i, Math.min(i + max, result.length())));</span>
        }

<span class="nc" id="L496">        return sb.append(&quot;\&quot;.toString() + \&quot;&quot;).toString();</span>
    }


    @Override
    protected void generateDao(TableDefinition table) {
<span class="fc" id="L502">        JavaWriter out = newJavaWriter(getFile(table, GeneratorStrategy.Mode.DAO));</span>
<span class="fc" id="L503">        LOG.info(&quot;Generating DAO&quot;, out.file().getName());</span>
<span class="fc" id="L504">        generateDao(table, out);</span>
<span class="fc" id="L505">        closeJavaWriter(out);</span>
<span class="fc" id="L506">    }</span>

    protected void generateDao(TableDefinition table, JavaWriter out) {
<span class="fc" id="L509">        UniqueKeyDefinition key = table.getPrimaryKey();</span>
<span class="fc" id="L510">        int size = key.getKeyColumns().size();</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">        if (key == null) {</span>
<span class="nc" id="L512">            LOG.info(&quot;Skipping DAO generation&quot;, out.file().getName());</span>
<span class="nc" id="L513">            return;</span>
        }

<span class="fc" id="L516">        final String className = getStrategy().getJavaClassName(table, GeneratorStrategy.Mode.DAO);</span>
<span class="fc" id="L517">        final List&lt;String&gt; interfaces = out.ref(getStrategy().getJavaClassImplements(table, GeneratorStrategy.Mode.DAO));</span>
<span class="fc" id="L518">        final String tableRecord = out.ref(getStrategy().getFullJavaClassName(table, GeneratorStrategy.Mode.RECORD));</span>
<span class="fc" id="L519">        final String daoImpl = out.ref(DAOImpl.class);</span>
<span class="fc" id="L520">        final String tableIdentifier = out.ref(getStrategy().getFullJavaIdentifier(table), 2);</span>
<span class="fc" id="L521">        String tType = &quot;Void&quot;;</span>


<span class="fc" id="L524">        String pType = out.ref(getStrategy().getFullJavaClassName(table, GeneratorStrategy.Mode.POJO));</span>

<span class="fc" id="L526">        List&lt;ColumnDefinition&gt; keyColumns = key.getKeyColumns();</span>

<span class="pc bpc" id="L528" title="1 of 2 branches missed.">        if (keyColumns.size() == 1) {</span>
<span class="fc" id="L529">            tType = getJavaType(keyColumns.get(0).getType(resolver(out)), out, GeneratorStrategy.Mode.POJO);</span>
        }
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">        if (keyColumns.size() &lt;= Constants.MAX_ROW_DEGREE) {</span>
<span class="fc" id="L532">            String generics = &quot;&quot;;</span>
<span class="fc" id="L533">            String separator = &quot;&quot;;</span>

<span class="fc bfc" id="L535" title="All 2 branches covered.">            for (ColumnDefinition column : keyColumns) {</span>
<span class="fc" id="L536">                generics += separator + out.ref(getJavaType(column.getType(resolver(out)), out));</span>


<span class="fc" id="L539">                separator = &quot;, &quot;;</span>
<span class="fc" id="L540">            }</span>

<span class="fc" id="L542">        } else {</span>
<span class="nc" id="L543">            tType = Record.class.getName();</span>
        }


<span class="fc" id="L547">        printPackage(out, table, GeneratorStrategy.Mode.DAO);</span>
<span class="fc" id="L548">        tType = out.ref(tType);</span>
<span class="fc" id="L549">        out.println(&quot;import org.jooq.impl.DefaultConfiguration;&quot;);</span>
<span class="fc" id="L550">        generateDaoClassJavadoc(table, out);</span>
<span class="fc" id="L551">        printClassAnnotations(out, table, GeneratorStrategy.Mode.DAO);</span>

<span class="pc bpc" id="L553" title="1 of 2 branches missed.">        if (generateSpringAnnotations())</span>
<span class="fc" id="L554">            out.println(&quot;@%s&quot;, out.ref(&quot;org.springframework.stereotype.Repository&quot;));</span>


<span class="fc" id="L557">        out.println(&quot;public class %s extends %s&lt;%s, %s, %s&gt;[[before= implements ][%s]] {&quot;, className, daoImpl, tableRecord, pType, tType, interfaces);</span>

        // Default constructor
        // -------------------
<span class="fc" id="L561">        out.javadoc(&quot;Create a new %s without any configuration&quot;, className);</span>



<span class="fc" id="L565">        out.println(&quot;public %s() {&quot;, className);</span>
<span class="fc" id="L566">        out.println(&quot;super(%s, %s.class);&quot;, tableIdentifier, pType);</span>
<span class="fc" id="L567">        out.println(&quot;}&quot;);</span>


        // Initialising constructor
        // ------------------------


<span class="fc" id="L574">        out.javadoc(&quot;Create a new %s with an attached configuration&quot;, className);</span>

<span class="fc" id="L576">        printDaoConstructorAnnotations(table, out);</span>
<span class="fc" id="L577">        out.println(&quot;public %s(%s configuration) {&quot;, className, Configuration.class);</span>
<span class="fc" id="L578">        out.println(&quot;super(%s, %s.class, configuration);&quot;, tableIdentifier, pType);</span>
<span class="fc" id="L579">        out.println(&quot;}&quot;);</span>


        // Template method implementations
        // -------------------------------

<span class="fc" id="L585">        out.overrideInherit();</span>
<span class="fc" id="L586">        printNonnullAnnotation(out);</span>
<span class="fc" id="L587">        out.println(&quot;public %s getId(%s object) {&quot;, tType, pType);</span>

<span class="pc bpc" id="L589" title="1 of 2 branches missed.">        if (keyColumns.size() == 1) {</span>

<span class="fc" id="L591">            out.println(&quot;return object.%s();&quot;, getStrategy().getJavaGetterName(keyColumns.get(0), GeneratorStrategy.Mode.POJO));</span>
        }

        // [#2574] This should be replaced by a call to a method on the target table's Key type
        else {
<span class="nc" id="L596">            String params = &quot;&quot;;</span>
<span class="nc" id="L597">            String separator = &quot;&quot;;</span>

<span class="nc bnc" id="L599" title="All 2 branches missed.">            for (ColumnDefinition column : keyColumns) {</span>

<span class="nc" id="L601">                params += separator + &quot;object.&quot; + getStrategy().getJavaGetterName(column, GeneratorStrategy.Mode.POJO) + &quot;()&quot;;</span>

<span class="nc" id="L603">                separator = &quot;, &quot;;</span>
<span class="nc" id="L604">            }</span>


<span class="nc" id="L607">            out.println(&quot;return compositeKeyRecord(%s);&quot;, params);</span>
        }


<span class="fc" id="L611">        out.println(&quot;}&quot;);</span>

<span class="fc bfc" id="L613" title="All 2 branches covered.">        for (ColumnDefinition column : table.getColumns()) {</span>
<span class="fc" id="L614">            final String colName = column.getOutputName();</span>
<span class="fc" id="L615">            final String colClass = getStrategy().getJavaClassName(column);</span>
<span class="fc" id="L616">            final String colTypeFull = getJavaType(column.getType(resolver(out)), out);</span>
<span class="fc" id="L617">            final String colType = out.ref(colTypeFull);</span>
<span class="fc" id="L618">            final String colIdentifier = out.ref(getStrategy().getFullJavaIdentifier(column), colRefSegments(column));</span>

            // fetchRangeOf[Column]([T]...)
            // -----------------------
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">            if (!printDeprecationIfUnknownType(out, colTypeFull))</span>
<span class="fc" id="L623">                out.javadoc(&quot;Fetch records that have &lt;code&gt;%s BETWEEN lowerInclusive AND upperInclusive&lt;/code&gt;&quot;, colName);</span>

<span class="fc" id="L625">            printNonnullAnnotation(out);</span>
<span class="fc" id="L626">            out.println(&quot;public %s&lt;%s&gt; fetchRangeOf%s(%s lowerInclusive, %s upperInclusive) {&quot;, List.class, pType, colClass, colType, colType);</span>
<span class="fc" id="L627">            out.println(&quot;return fetchRange(%s, lowerInclusive, upperInclusive);&quot;, colIdentifier);</span>
<span class="fc" id="L628">            out.println(&quot;}&quot;);</span>


            // fetchBy[Column]([T]...)
            // -----------------------
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">            if (!printDeprecationIfUnknownType(out, colTypeFull))</span>
<span class="fc" id="L634">                out.javadoc(&quot;Fetch records that have &lt;code&gt;%s IN (values)&lt;/code&gt;&quot;, colName);</span>


<span class="fc" id="L637">            printNonnullAnnotation(out);</span>
<span class="fc" id="L638">            out.println(&quot;public %s&lt;%s&gt; fetchBy%s(%s... values) {&quot;, List.class, pType, colClass, colType);</span>
<span class="fc" id="L639">            out.println(&quot;return fetch(%s, values);&quot;, colIdentifier);</span>
<span class="fc" id="L640">            out.println(&quot;}&quot;);</span>
            //DeleteBy[columns](Void)


            // fetchOneBy[Column]([T])
            // -----------------------
            ukLoop:
<span class="fc bfc" id="L647" title="All 2 branches covered.">            for (UniqueKeyDefinition uk : column.getUniqueKeys()) {</span>

                // If column is part of a single-column unique key...
<span class="pc bpc" id="L650" title="2 of 4 branches missed.">                if (uk.getKeyColumns().size() == 1 &amp;&amp; uk.getKeyColumns().get(0).equals(column)) {</span>
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">                    if (!printDeprecationIfUnknownType(out, colTypeFull))</span>
<span class="fc" id="L652">                        out.javadoc(&quot;Fetch a unique record that has &lt;code&gt;%s = value&lt;/code&gt;&quot;, colName);</span>


<span class="fc" id="L655">                    printNullableAnnotation(out);</span>
<span class="fc" id="L656">                    out.println(&quot;public %s fetchOneBy%s(%s value) {&quot;, pType, colClass, colType);</span>
<span class="fc" id="L657">                    out.println(&quot;return fetchOne(%s, value);&quot;, colIdentifier);</span>
<span class="fc" id="L658">                    out.println(&quot;}&quot;);</span>


<span class="fc" id="L661">                    break ukLoop;</span>
                }
<span class="nc" id="L663">            }</span>
<span class="fc" id="L664">        }</span>

        //For GET method for composite primary key.
<span class="fc" id="L667">        out.javadoc(&quot;Created custom fetchRecord Method&quot;);</span>
<span class="fc" id="L668">        out.print(&quot;public %s fetchRecord(&quot;, pType);</span>
<span class="fc" id="L669">        int flag = 0;</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">        for (ColumnDefinition column : table.getColumns()) {</span>
<span class="fc" id="L671">            final String colClass = getStrategy().getJavaClassName(column);</span>
<span class="fc" id="L672">            final String colTypeFull = getJavaType(column.getType(resolver(out)), out);</span>
<span class="fc" id="L673">            final String colType1 = out.ref(colTypeFull);</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">            if (key == column.getPrimaryKey()) {</span>
<span class="pc bpc" id="L675" title="1 of 2 branches missed.">                if (flag != (size - 1)) {</span>
<span class="nc" id="L676">                    out.print(&quot;%s %s,&quot;, colType1, colClass);</span>
<span class="nc" id="L677">                    flag++;</span>
                } else {
<span class="fc" id="L679">                    out.println(&quot;%s %s){&quot;, colType1, colClass);</span>
                }
            }
<span class="fc" id="L682">        }</span>
<span class="fc" id="L683">        out.print(&quot;return this.ctx().selectFrom(%s).where(&quot;,  tableIdentifier);</span>
<span class="fc" id="L684">        int flag2 = 0;</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">        for (ColumnDefinition column : table.getColumns()) {</span>
<span class="fc" id="L686">            final String colClass1 = getStrategy().getJavaClassName(column);</span>
<span class="fc" id="L687">            final String colTypeFull1 = getJavaType(column.getType(resolver(out)), out);</span>
<span class="fc" id="L688">            final String colType1 = out.ref(colTypeFull1);</span>
<span class="fc" id="L689">            final String colIdentifier1 = out.ref(getStrategy().getFullJavaIdentifier(column), colRefSegments(column));</span>
<span class="fc bfc" id="L690" title="All 2 branches covered.">            if (key == column.getPrimaryKey()) {</span>
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">                if (flag2 != (size - 1)) {</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">                    if (flag2 == 0) {</span>
<span class="nc" id="L693">                        out.print(&quot;%s.eq(%s).and(&quot;, colIdentifier1, colClass1);</span>
                    } else {
<span class="nc" id="L695">                        out.print(&quot;%s.eq(%s)).and(&quot;, colIdentifier1, colClass1);</span>
                    }
<span class="nc" id="L697">                    flag2++;</span>
                } else {
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">                    if (size == 1) {</span>
<span class="fc" id="L700">                        out.println(&quot;%s.eq(%s)).fetchOneInto(%s.class);&quot;, colIdentifier1, colClass1, pType);</span>
<span class="fc" id="L701">                        out.println(&quot;}&quot;);</span>
                    } else {
<span class="nc" id="L703">                        out.println(&quot;%s.eq(%s))).fetchOneInto(%s.class);&quot;, colIdentifier1, colClass1, pType);</span>
<span class="nc" id="L704">                        out.println(&quot;}&quot;);</span>
                    }
                }
            }
<span class="fc" id="L708">        }</span>

        //For Insert Method
<span class="fc" id="L711">        out.javadoc(&quot;Created custom Insert records Method&quot;);</span>
<span class="fc" id="L712">        out.println(&quot;public %s insertRecord(%s classObject) {&quot;, pType, pType);</span>
<span class="fc" id="L713">        out.println(&quot;%s record=this.ctx().newRecord(%s);&quot;, tableRecord, tableIdentifier);</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">        for (ColumnDefinition column : table.getColumns()) {</span>
<span class="fc" id="L715">            final String colClass = getStrategy().getJavaClassName(column);</span>
<span class="pc bpc" id="L716" title="1 of 2 branches missed.">            if (size == 1) {</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">                if (key != column.getPrimaryKey()) {</span>
<span class="fc" id="L718">                    out.println(&quot;record.set%s(classObject.get%s());&quot;, colClass, colClass);</span>
                }
            }
            else {
<span class="nc" id="L722">                out.println(&quot;record.set%s(classObject.get%s());&quot;, colClass, colClass);</span>
            }
<span class="fc" id="L724">        }</span>
<span class="fc" id="L725">        out.println(&quot;record.store();&quot;);</span>
<span class="fc" id="L726">        out.println(&quot;%s result=record.into(%s.class);&quot;, pType, pType);</span>
<span class="fc" id="L727">        out.println(&quot;return result;&quot;);</span>
<span class="fc" id="L728">        out.println(&quot;}&quot;);</span>


<span class="pc bpc" id="L731" title="1 of 2 branches missed.">        if (size &gt; 1) {</span>
            //For Update COMPOSITE KEYS
<span class="nc" id="L733">            out.javadoc(&quot;Created custom Update record Method&quot;);</span>
<span class="nc" id="L734">            out.println(&quot;public int updateRecord(%s classObject){&quot;, pType);</span>
<span class="nc" id="L735">            out.println(&quot;int result=this.ctx().update(%s)&quot;, tableIdentifier);</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">            for (ColumnDefinition column1 : table.getColumns()) {</span>
<span class="nc" id="L737">                final String colClass1 = getStrategy().getJavaClassName(column1);</span>
<span class="nc" id="L738">                final String colIdentifier1 = out.ref(getStrategy().getFullJavaIdentifier(column1), colRefSegments(column1));</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">                if (key != column1.getPrimaryKey()) {</span>
<span class="nc" id="L740">                    out.println(&quot;.set(%s,classObject.get%s())&quot;, colIdentifier1, colClass1);</span>
                }
<span class="nc" id="L742">            }</span>
<span class="nc" id="L743">            out.print(&quot;.where(&quot;);</span>
<span class="nc" id="L744">            int flag1 = 0;</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">            for (ColumnDefinition column : table.getColumns()) {</span>
<span class="nc" id="L746">                final String colClass1 = getStrategy().getJavaClassName(column);</span>
<span class="nc" id="L747">                final String colTypeFull1 = getJavaType(column.getType(resolver(out)), out);</span>
<span class="nc" id="L748">                final String colType1 = out.ref(colTypeFull1);</span>
<span class="nc" id="L749">                final String colIdentifier1 = out.ref(getStrategy().getFullJavaIdentifier(column), colRefSegments(column));</span>

<span class="nc bnc" id="L751" title="All 2 branches missed.">                if (key == column.getPrimaryKey()) {</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">                    if (flag1 != (size - 1)) {</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">                        if (flag1 == 0) {</span>
<span class="nc" id="L754">                            out.print(&quot;%s.eq(classObject.get%s()).and(&quot;, colIdentifier1, colClass1);</span>
                        } else {
<span class="nc" id="L756">                            out.print(&quot;%s.eq(classObject.get%s())).and(&quot;, colIdentifier1, colClass1);</span>
                        }
<span class="nc" id="L758">                        flag1++;</span>
                    } else {
<span class="nc" id="L760">                        out.println(&quot;%s.eq(classObject.get%s()))).execute();&quot;, colIdentifier1, colClass1, pType);</span>
<span class="nc" id="L761">                        out.println(&quot;return result;&quot;);</span>
<span class="nc" id="L762">                        out.println(&quot;}&quot;);</span>
                    }
                }
<span class="nc" id="L765">            }</span>
            //For Delete COMPOSITE KEYS
<span class="nc" id="L767">            out.javadoc(&quot;Created custom Delete method &quot;);</span>
<span class="nc" id="L768">            out.print(&quot;public int deleteRecord(&quot;);</span>
<span class="nc" id="L769">            int flag5 = 0;</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">            for (ColumnDefinition column : table.getColumns()) {</span>
<span class="nc" id="L771">                final String colClass = getStrategy().getJavaClassName(column);</span>
<span class="nc" id="L772">                final String colTypeFull = getJavaType(column.getType(resolver(out)), out);</span>
<span class="nc" id="L773">                final String colType1 = out.ref(colTypeFull);</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">                if (key == column.getPrimaryKey()) {</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">                    if (flag5 != (size - 1)) {</span>
<span class="nc" id="L776">                        out.print(&quot;%s %s,&quot;, colType1, colClass);</span>
<span class="nc" id="L777">                        flag5++;</span>
                    } else {
<span class="nc" id="L779">                        out.println(&quot;%s %s){&quot;, colType1, colClass);</span>
                    }
                }
<span class="nc" id="L782">            }</span>
<span class="nc" id="L783">            out.print(&quot;return this.ctx().deleteFrom(%s).where(&quot;, tableIdentifier);</span>
<span class="nc" id="L784">            int flag6 = 0;</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">            for (ColumnDefinition column : table.getColumns()) {</span>
<span class="nc" id="L786">                final String colClass1 = getStrategy().getJavaClassName(column);</span>
<span class="nc" id="L787">                final String colTypeFull1 = getJavaType(column.getType(resolver(out)), out);</span>
<span class="nc" id="L788">                final String colType1 = out.ref(colTypeFull1);</span>
<span class="nc" id="L789">                final String colIdentifier1 = out.ref(getStrategy().getFullJavaIdentifier(column), colRefSegments(column));</span>

<span class="nc bnc" id="L791" title="All 2 branches missed.">                if (key == column.getPrimaryKey()) {</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">                    if (flag6 != (size - 1)) {</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">                        if (flag6 == 0) {</span>
<span class="nc" id="L794">                            out.print(&quot;%s.eq(%s).and(&quot;, colIdentifier1, colClass1);</span>
                        } else {
<span class="nc" id="L796">                            out.print(&quot;%s.eq(%s)).and(&quot;, colIdentifier1, colClass1);</span>
                        }
<span class="nc" id="L798">                        flag6++;</span>
                    }
                    else {
<span class="nc" id="L801">                        out.println(&quot;%s.eq(%s))).execute();&quot;, colIdentifier1, colClass1, pType);</span>
<span class="nc" id="L802">                        out.println(&quot;}&quot;);</span>
                    }
                }
<span class="nc" id="L805">            }</span>
<span class="nc" id="L806">        }</span>
        else {
            //For Delete single primary key
<span class="fc bfc" id="L809" title="All 2 branches covered.">            for (ColumnDefinition column : table.getColumns()) {</span>
<span class="fc" id="L810">                final String colClass = getStrategy().getJavaClassName(column);</span>
<span class="fc" id="L811">                final String colTypeFull = getJavaType(column.getType(resolver(out)), out);</span>
<span class="fc" id="L812">                final String colType = out.ref(colTypeFull);</span>
<span class="fc" id="L813">                final String colIdentifier = out.ref(getStrategy().getFullJavaIdentifier(column), colRefSegments(column));</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">                if (key == column.getPrimaryKey()) {</span>
<span class="fc" id="L815">                    out.javadoc(&quot;Created custom Delete record Method&quot;);</span>
<span class="fc" id="L816">                    out.println(&quot;public int deleteRecord(%s %s){&quot;, colType, colClass);</span>
<span class="fc" id="L817">                    out.println(&quot;int result=this.ctx().deleteFrom(%s).where(%s.eq(%s)).execute();&quot;, tableIdentifier, colIdentifier, colClass);</span>
<span class="fc" id="L818">                    out.println(&quot;return result;&quot;);</span>
<span class="fc" id="L819">                    out.println(&quot;}&quot;);</span>
                }
<span class="fc" id="L821">            }</span>
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">            for (ColumnDefinition column : table.getColumns()) {</span>
<span class="fc" id="L823">                final String colClass = getStrategy().getJavaClassName(column);</span>
<span class="fc" id="L824">                final String colTypeFull = getJavaType(column.getType(resolver(out)), out);</span>
<span class="fc" id="L825">                final String colType = out.ref(colTypeFull);</span>
<span class="fc" id="L826">                final String colIdentifier = out.ref(getStrategy().getFullJavaIdentifier(column), colRefSegments(column));</span>
                //For update single primary key
<span class="fc" id="L828">                out.javadoc(&quot;Created custom Update record Method&quot;);</span>
<span class="fc" id="L829">                out.println(&quot;public int updateRecord(%s classObject){&quot;, pType);</span>
<span class="fc" id="L830">                out.println(&quot;int result=this.ctx().update(%s)&quot;, tableIdentifier);</span>
<span class="fc bfc" id="L831" title="All 2 branches covered.">                for (ColumnDefinition column1 : table.getColumns()) {</span>
<span class="fc" id="L832">                    final String colClass1 = getStrategy().getJavaClassName(column1);</span>
<span class="fc" id="L833">                    final String colIdentifier1 = out.ref(getStrategy().getFullJavaIdentifier(column1), colRefSegments(column1));</span>
<span class="fc bfc" id="L834" title="All 2 branches covered.">                    if (key != column1.getPrimaryKey()) {</span>
<span class="fc" id="L835">                        out.println(&quot;.set(%s,classObject.get%s())&quot;, colIdentifier1, colClass1);</span>
                    }
<span class="fc" id="L837">                }</span>
<span class="fc" id="L838">                out.println(&quot;.where(%s.eq(classObject.get%s())).execute();&quot;, colIdentifier, colClass);</span>
<span class="fc" id="L839">                out.println(&quot;return result;&quot;);</span>
<span class="fc" id="L840">                out.println(&quot;}&quot;);</span>
<span class="fc" id="L841">                break;</span>
            }
        }
<span class="fc" id="L844">        generateDaoClassFooter(table, out);</span>
<span class="fc" id="L845">        out.println(&quot;}&quot;);</span>
<span class="fc" id="L846">    }</span>
    protected String ref(String clazzOrId, int keepSegments) {
<span class="nc bnc" id="L848" title="All 2 branches missed.">        return clazzOrId == null ? null : ref(Arrays.asList(clazzOrId), keepSegments).get(0);</span>
    }


    protected List&lt;String&gt; ref(List&lt;String&gt; clazzOrId, int keepSegments) {
<span class="nc bnc" id="L853" title="All 2 branches missed.">        return clazzOrId == null ? Collections.&lt;String&gt;emptyList() : clazzOrId;</span>
    }
    //
//    /**
//     * Subclasses may override this method to provide alternative DAO
//     * constructor annotations, such as DI annotations. [#10801]
//     */
    protected void printDaoConstructorAnnotations(TableDefinition table, JavaWriter out) {
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">        if (generateSpringAnnotations())</span>
<span class="fc" id="L862">            out.println(&quot;@%s&quot;, out.ref(&quot;org.springframework.beans.factory.annotation.Autowired&quot;));</span>
<span class="fc" id="L863">    }</span>


    private int colRefSegments(Definition column) {
<span class="pc bpc" id="L867" title="2 of 4 branches missed.">        if (column instanceof TypedElementDefinition &amp;&amp; ((TypedElementDefinition&lt;?&gt;) column).getContainer() instanceof UDTDefinition)</span>
<span class="nc" id="L868">            return 2;</span>

<span class="pc bpc" id="L870" title="1 of 2 branches missed.">        if (!getStrategy().getInstanceFields())</span>
<span class="nc" id="L871">            return 2;</span>

<span class="fc" id="L873">        return 3;</span>
    }




}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>